(* Notes:
     In character categories and literals, whitespace must be absent.
     In all other rules whitespace is ignored.
*)

(* Character categories *)
hex_digit      = "0" ;.. "9" | "A" ;.. "F" | "a" ;.. "f" ;
octal_digit    = "0" ;.. "7" ;
decimal_digit  = "0" ;.. "9" ;
unicode_digit  = ? a Unicode character categorized as "Decimal Digit" ? ;
unicode_math   = ? a Unicode character categorized as "Symbol, Math" ? ;
unicode_letter = ? a Unicode character categorized as "Letter" ? ;
text_character = ? space, tab, or any Unicode character greater than U+0020 ? ;
math_symbol    = ( unicode_math - "=" ) | "%" | "*" | "/" ;
character      = text_character | newline | carriage_return ;
letter         = unicode_letter | "_" ;

(* Literals *)
identifier        = letter , { letter | unicode_digit } ;
scoped_identifier = [ identifier , "." ] , identifier ;

hex_literal      = "0" , ( "x" | "X" ) , { hex_digit } ;
octal_literal    = "0" , { octal_digit } ;
decimal_literal  = ( "1" , "9" ) , { decimal_digit } ;

mantissa = "0" | decimal_literal ;
decimals = decimal_digit , { decimal_digit } ;
exponent = ( "e" | "E" ) , [ "+" | "-" ] , decimals ;

integer_literal = hex_literal | decimal_literal | octal_literal ;
real_literal    = mantissa , "." , [ decimals ] , [ exponent ]
                | mantissa , exponent
                | "." , decimals | [ exponent ] ;

number_literal  = integer_literal | real_literal ;
text_literal    = '"' , { text_character } , '"' ;

operator   = math_symbol , { math_symbol } ;

(* Types *)
named_type    = scoped_identifier ;
array_type    = "[" , [ ".." | number_literal ] , "]" , type ;
pointer_type  = "*" , type ;
function_type = "(" , [ type , { "," , type } ] , ")" , [ "->" , type ] ;
type          = array_type | function_type | named_type | pointer_type ;

(* Statements *)
assign_stmt = scoped_identifier , [ operator ] , "=" , expr ;
expr_range  = expr , ".." , expr ;
each_range  = identifier , [ "," , identifier ] , "in" , ( expr | expr_range ) ;
for_range   = mutable_decl , expr , ";" , assign_stmt ;
for_stmt    = "for" , ( for_range | each_range ) , assign_stmt ;
while_stmt  = "while" , expr , stmt ;
if_stmt     = "if" , expr , stmt , [ "else" , stmt ] ;
block       = "{" , { stmt } , "}" ;
stmt        = block | decl | expr , ";" | if_stmt | for_stmt | assign_stmt , ";" ;

(* Expressions *)
function_param = identifier , ":" , type
function_expr  = "(" , [ function_param , { "," , function_param } ] , ")" , [ "->" , type ] , stmt ;
group_expr     = "(" , expr , ")";
value_expr    = scoped_ident | text_literal | number_literal ;

base_expr   = value_expr | group_expr | function_expr ;
call_expr   = base_expr , { "(" , [ expr , { "," , expr } ] , ")" } ;
prefix_expr = { operator } , prefix_expr ;
infix_expr  = prefix_expr , { operator , infix_expr } ;
expr        = infix_expr ;

(* Notes:
     Above is the non-left-recurive grammar which can be used to verify that a
     given sentence matches the grammar (with an LL(3) parser).

     TODO: Evaluate whether function_expr should be prefixed with a keyword
     (like "func") to simplify the grammar to be parsable by an LL(1) parser.
     This will probably improve the ability of syntax highlighters to
     distinguish between the rules for group_expr and function_expr.

     The abstract syntax tree is more lenient than the grammar and is better
     represented by the following left-recursive definition of "expr".

call_expr      = expr , { "(" , [ expr , { "," , expr } ] , ")" } ;
prefix_expr    = operator , expr ;
infix_expr     = expr , operator , expr ; (* TODO: fix left recursion *)
expr           = value_expr | group_expr | function_expr | call_expr | prefix_expr | infix_expr ;
 *)

(* Definitions *)
enum_separator = ">" , identifier ;
enum_value     = identifier , [ integer_literal ] , [ text_literal ] ;
enum_defn      = "enum" , [ type ] , "{" , { enum_value | enum_separator } , "}" ;
struct_field   = identifier , ":" , type , ";" ;
struct_defn    = "struct" , "{" , { struct_field } , "}" ;
defn           = struct_defn | enum_defn ;

(* Declarations *)
constant_decl = identifier , "::" , ( defn | expr , ";" ) ;
mutable_decl  = identifier , ":" , ( type | "=" , expr | type , "=" , expr ) , ";" ;
decl = constant_decl | mutable_decl ;
