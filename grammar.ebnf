(* Notes:
     In character categories and literals, whitespace must be absent.
     In all other rules whitespace is ignored.
*)

(* Character categories *)
hex_digit      = "0" ;.. "9" | "A" ;.. "F" | "a" ;.. "f" ;
octal_digit    = "0" ;.. "7" ;
decimal_digit  = "0" ;.. "9" ;
unicode_digit  = ? a Unicode character categorized as "Decimal Digit" ? ;
unicode_math   = ? a Unicode character categorized as "Symbol, Math" ? ;
unicode_letter = ? a Unicode character categorized as "Letter" ? ;
text_character = ? space, tab, or any Unicode character greater than U+0020 ? ;
math_symbol    = ( unicode_math - ( "=" | ">" | "<" | "~" ) ) | "%" | "*" | "/" ;
character      = text_character | newline | carriage_return ;

(* Literals *)
identifier        = unicode_letter , { unicode_letter | unicode_digit | "_" } ;
scoped_identifier = [ identifier , "." ] , identifier ;

hex_literal      = "0" , ( "x" | "X" ) , { hex_digit } ;
octal_literal    = "0" , { octal_digit } ;
decimal_literal  = ( "1" , "9" ) , { decimal_digit } ;

mantissa = "0" | decimal_literal ;
decimals = decimal_digit , { decimal_digit } ;
exponent = ( "e" | "E" ) , [ "+" | "-" ] , decimals ;

integer_literal = hex_literal | decimal_literal | octal_literal ;
real_literal    = mantissa , "." , [ decimals ] , [ exponent ]
                | mantissa , exponent
                | "." , decimals | [ exponent ] ;

number_literal  = integer_literal | real_literal ;
text_literal    = '"' , { text_character } , '"' ;

operator   = math_symbol , { math_symbol }
           | "_" , identifier , [ "_" ] ;

(* Types *)
named_type    = scoped_identifier ;
array_type    = "[" , [ ".." | number_literal ] , "]" , type ;
pointer_type  = "^" , type ;
function_type = "(" , [ type , { "," , type } ] , ")" , [ "->" , type ] ;
type          = array_type | function_type | named_type | pointer_type ;

(* Statements *)
done_stmt   = "done" , expr ;
return_stmt = "return" , expr ;
assign_stmt = scoped_identifier , [ operator ] , "=" , expr ;
expr_range  = expr , ".." , expr ;
each_range  = identifier , [ "," , identifier ] , "in" , ( expr | expr_range ) ;
for_range   = mutable_decl , expr , ";" , assign_stmt ;
for_stmt    = "for" , ( for_range | each_range ) , assign_stmt ;
while_stmt  = "while" , expr , block ;
if_stmt     = "if" , expr , block , [ "else" , block ] ;
stmt        = if_stmt | for_stmt | ( expr, assign_stmt , done_stmt, return_stmt ) , ";" ;

short_block = ":" , stmt ;
long_block  = "{" , { stmt | decl } , "}" ;
block       = short_block | long_block ;

(* Expressions *)
function_param = identifier , ":" , type
function_expr  = "func" , "(" , [ function_param , { "," , function_param } ] , ")" , [ "->" , type ] , block ;
group_expr     = "(" , expr , ")";
value_expr    = scoped_ident | text_literal | number_literal ;

base_expr     = value_expr | group_expr | function_expr ;
call_expr     = base_expr , { "(" , [ expr , { "," , expr } ] , ")" } ;
prefix_expr   = { operator | "~" | "^" |  } , call_expr ;
postfix_expr  = prefix_expr , { operator } ;
infix_expr    = postfix_expr , { operator , infix_expr } ;
greater_expr  = { ( ">=" | ">" ) , infix_expr } ;
lesser_expr   = { ( "<=" | "<" ) , infix_expr } ;
equality_expr = { "==" , infix_expr } ;
identity_expr = { "is" , infix_expr } ;
relation_expr = infix_expr , [ identity_expr | equality_expr | lesser_expr | greater_expr ] ;
logical_expr  = relation_expr , { ( "and" | "or" ) relative_expr } ;
expr          = logical_expr;

(* Notes:
     Above is the non-left-recurive grammar which can be used to verify that a
     given sentence matches the grammar (expressions only need a LL(1) parser).

     Valid abstract syntax trees are more lenient than the grammar and can be
     better represented by the following ambiguous left-recursive grammar rules.

call_expr     = expr , { "(" , [ expr , { "," , expr } ] , ")" } ;
indirect_expr = "~" , expr ;
address_expr  = "^" , expr ;
prefix_expr   = operator , expr ;
postfix_expr  = expr , operator ;
infix_expr    = expr , ( operator ) , expr ;
normal_expr   = value_expr | group_expr | function_expr | call_expr | indirect_expr
              | address_expr | prefix_expr | postfix_expr | infix_expr ;

     The grammar for comparison expressions in philomath is somewhat unusual
     compared to other languages in that it allows expression of relations in
     a more math-friendly style.  Here are a few examples:

             a == b == c    is equivalent to    (a == b) and (a == c)
             a <  b <= c    is equivalent to    (a <  b) and (b <= c)

greater_expr  = normal_expr , { ( ">=" | ">" ) , normal_expr } ;
lesser_expr   = normal_expr , { ( "<=" | "<" ) , normal_expr } ;
equality_expr = normal_expr , { "==" , normal_expr } ;
identity_expr = normal_expr , { "is" , normal_expr } ;
relation_expr = identity_expr | equality_expr | lesser_expr | greater_expr ;
logical_expr  = relation_expr , ( "and" | "or" ) , relative_expr ;

expr = normal_expr | relative_expr | logical_expr ;

 *)

(* Definitions *)
enum_separator = ">" , identifier ;
enum_value     = identifier , [ integer_literal ] , [ text_literal ] ;
enum_defn      = "enum" , [ type ] , "{" , { enum_value | enum_separator } , "}" ;
struct_field   = identifier , ":" , type , ";" ;
struct_defn    = "struct" , "{" , { struct_field } , "}" ;
defn           = struct_defn | enum_defn ;

(* Declarations *)
constant_decl = identifier , "::" , ( defn | expr , ";" ) ;
mutable_decl  = identifier , ":" , ( type | "=" , expr | type , "=" , expr ) , ";" ;
decl = constant_decl | mutable_decl ;
