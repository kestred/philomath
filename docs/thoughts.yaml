Preface: While notes.md is more organized and reasoned, I'm just tossing stray thoughts in here.

Hardware Extensibility:
  Bytecode Translation: |
    The user should be able to define their own translator that the compiler
    will use in the bytecode to machine language compilation step.
    This makes it easier to cross-compile, compile for a unique instruction set,
    or compiler to non-CPU targets like javascript or GPUs.

  Arbitrary Assembly: |
    In addition to just supporting inline assembly, the programmer should be
    able to use a custom or arbitrary assembly syntax and specify some way that
    the compiler translates that assembly into machine code.

    I am not sure whether that some way is with a "parsing function" or by
    specifying an external assembler program to be used to generate object code.

Name Mangling:
  Problem Space: |
    In general, I insist that "mangled" names are actually human readable.
    I should be able to run the GNU strings utility on the program and easily
    understand what each name is without the help of a demangler and without
    knowing anything about the mangling scheme.

    It would be nice to use C friendly mangled names and use a C friendly ABI.
    This would allow any existing C FFI to make calls to compiled philomath code.
    However, I feel like restricting the code generator to that may conflict
    with many of the other language goals; we will see.

    A good compromise would be to support C as a compilation target for anyone
    who wants to use a C FFI, but in the normal case just focus on making it
    easy to implement a Philomath FFI in other languages.

  Operator Overloading: |
    Each operator gets its own symbol name.
    For prefix operators, it must look like "NAME_"
    For postfix operators, it must look like "_NAME"
    For infix operators, it must look like "_NAME_"
    These names are restricted to C naming rules (ie. ASCII alphanumeric).

    For a type "bignum",
      unary prefix "-" is mangled to "neg__bignum"
      binary infix "+" is mangled to "bignum_add_bignum"
      unary postfix "_foo" is mangled to "bignum_foo"

    The compiler will give you an error if there are any conflicts.
    Normal philomath identifiers cannot begin or end with an underscore.

  Module Members: |
    These values are mangled by combining module names with values using a double underscore.
    For some module "math",
      the function "tanh" is mangled to "math__tanh"
      the operator "×" for a type "vec3" is mangled to "math__vec3_cross_vec3"

High-order Functions: |
  Argument Order:
    The conventional argument order for a higher-order function should
    generally have the function last.  The basic reason is so that it is easy
    to read a function when writing the block as an argument to the function call.

    Comparing the first option
      map(func(v: int) -> int) {
        a := valueToA(A);
        return calcBFromA(a);
      }, [1, 2, 3])

    To the second option
      map([1, 2, 3], func(v: int) -> int) {
        a := valueToA(A);
        return calcBFromA(a);
      })

    When using list (array) comprehensions, you might flip the argument around
    and say that it would be better to have the comprehension second (example below),
    but in general I think comprehensions are already short, while blocks can
    be arbitrarily long.  Additionally using list comprehensions typically
    obviates the need for "map", "filter", and "reduce" at all.

      map(func(v: int) -> int { return v+1 }, [
        a * 3 for a in array if a % 2 == 0
      ])

    Instead high-order functions can be very useful for building tools such as
    futures and promises for asynchronous programming.

  Eliding Types:
    High order functions work via first-class functions, but they are very
    ugly to read because of all the types.  They'd be much easier to use if
    it was possible to elide the argument and return types for function
    expressions which are passed directly as an argument.

      map([1, 2, 3], func(v) { return v + 1; })

    It should be fairly easy to infer all of the necessary types from the
    prototype and arguments of the calling function;  hopefully I'll still
    agree with this statement when implementing this feature later!

Code Safety:
  Warnings:
    - Misleading identation when using a short block (eg. multiple statements at the next line's identation)
  Errors:
    - Error for assigning to a value at block scope and not later using that value
  Site-disabled Checks:
    - Arithmetic operators are overflow checked by default (disable with directive).
    - Array accesses are bounds checked by default (disable with directive).
    - Variables are initialized to 0 by default (disable with directive (or ---?)).
  User Defined: |
    Users should be able write/customize/enable/disable both new and builtin
    validations (aka. warnings or errors) which can be applied at a variety of
    levels including; across all loaded files, in a single file, within a module,
    at the usage site of any function or variable, etc, etc.
    These validations should be definable within the source code of a program
    using the same language at the program (TODO -> compilation stages...)

Operator Exploration:
  Default Operators: |
    These operators are available by default
      arithmetic operators (+, -, /, *, %)
      arithmetic comparison operator (<=>)
      comparison operators (==, <, <=, >, >=, is, is not)
      logical operators (and, or)
      set operators (in, not in)
  Unicode Operator Libraries:
    Operator Symbols: |
      These operators are provided via libraries as both unicode symbol and
      via their ascii operator name (eg. _operator_).
      Mixing the use of unicode and names within one file will be discouraged
      via a user defined validation in each library (disableable).
      Most of these would probably be a BAD IDEA, but enjoyable academic eccentrics.

    Acceptable Unicode: |
      Similar characters must be disallowed.
      From Latin Supplement 1
        U+00AC Not sign
        U+00B0 Plus-minus sign
        U+00B2 Superscript two
        U+00B3 Superscript three
        U+00B7 Middle dot   (also see U+22C5 Dot Operator)
        U+00B9 Superscript one
        U+00BC-U+00BE Vulgar fractions
        U+00D7 Multiplication
        U+00F7 Division sign
      From Mathematical Operators
        Almost everything except "small", "large", or "n-ary" variants
        Exclude tilde, reversed tilde, division (/), set minus (\),
        minus (-), divides (|), asterisk, bullet, ratio, and star.

    Mathematics Operators: |
      These might actually be useful?
        square root (√ or sqrt_)
        cube root (∛ cbrt_)
        fourth root (∜ frrt_)
        multiplication (× _cross_)
        devisions (÷ _divide_)
        dot product	(⋅ _dot_)
        sum (∑ or sum_)
          would be interesting to use as a prefix operator for arrays
          with array comprehensions, this could be cool

            ∑[a+2 for a in array if a % 2 == 0]

        product (∏ or product_)
          would be interesting to use as a prefix operator for arrays
          with array comprehensions, this could be cool

            ∏[a+2 for a in array if a % 2 == 0]

        confidence (± or _plusminus_)
          could maybe be useful for something

    Comparison Operators: |
      The actual "or equals" operators (≤, ≥)

    Logical Operators: |
      These could be defined for collections like arrays, etc
        union (∩ or _union_)
        intersection (∪ or _intersect_)
        element of (∈ or "in" or _in_)
        not element of (∉ or "not in" or _not_in_)
        includes (∋ or _includes_)
        excludes (∌ or _excludes_)
        subset (⊆ or _subset_)
        superset (⊇ or _superset_)
        proper subset (⊂ or ⊊ or _psubset_)
        proper superset (⊃ or ⊋ or _psubset_)
        forall (∀ or forall_)
          would be interesting to use as a prefix operator returning a functional
          it could be cool if we could somehow use syntax like this

            ∀[0,1,2] { return (2 * n) > (n + 2); }

      These could be defined for... booleans? Very very eccentric.
        conjunction (∧ or _conjoin_)
        disjunction (∨ or _disjoin_)
        not (¬ or _not_)

    Relational Operators:
      Left Join (⋉ or _ljoin_)
      Right Join (⋊ or _rjoin_)
      Natural join (⋈ or _join_)
